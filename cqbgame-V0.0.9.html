<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>CQB Shooter — Weapon Menu (Press E) + Upgrades (U) + Flamethrower + Grenade</title>
<style>
  :root{
    --bg:#111;
    --panel:rgba(0,0,0,0.6);
    --accent:#0f0;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  canvas{display:block}
  #menu {
    position: absolute;
    top:0;left:0;width:100%;height:100%;
    display:flex;flex-direction:column;justify-content:center;align-items:center;
    background: radial-gradient(circle, #111 40%, #000 100%);
    z-index: 30;
  }
  #menu h1{font-size:48px;margin:0 0 20px;color:var(--accent);text-shadow:0 0 8px var(--accent)}
  #menu button{background:var(--accent);border:none;color:#000;padding:12px 32px;font-size:18px;border-radius:10px;cursor:pointer}
  #hud{
    position:absolute; left:12px; top:12px; z-index:20;
    background:var(--panel); padding:8px 10px; border-radius:8px;
    display:flex;gap:12px; align-items:center;
  }
  #weaponBtn, #upgradeBtn{
    background:transparent; border:1px solid rgba(255,255,255,0.06); color:#fff; padding:6px 10px; border-radius:6px; cursor:pointer;
  }

  /* Weapon popup */
  .popupOverlay{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:520px; max-width:92%; background:linear-gradient(#111,#0b0b0b);
    border-radius:12px; padding:18px; box-shadow:0 8px 30px rgba(0,0,0,0.7);
    z-index:40; display:none;
  }
  .popupOverlay h2{margin:0 0 12px;color:var(--accent)}
  .weaponList{display:flex; gap:10px; flex-wrap:wrap}
  .weaponCard{
    flex:1 1 150px; min-width:140px;
    background:rgba(255,255,255,0.03); padding:10px; border-radius:8px; cursor:pointer;
    border:2px solid transparent; transition:transform .08s, border-color .12s, background .12s;
  }
  .weaponCard:hover{transform:translateY(-4px); background: rgba(255,255,255,0.04)}
  .weaponCard.active{border-color:var(--accent); box-shadow:0 6px 18px rgba(0,255,0,0.06)}
  .weaponName{font-weight:700;margin-bottom:6px}
  .weaponStat{font-size:13px;color:#cfcfcf;margin:2px 0}
  #closeWeapons{margin-top:12px; background:var(--accent); border:none; padding:10px 14px; color:#000; border-radius:8px; cursor:pointer}

  /* Upgrade UI */
  .upgradeRow{display:flex;align-items:center;gap:10px;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;margin-bottom:8px}
  .upgradeTitle{flex:1;font-weight:700}
  .upgradeBars{display:flex;gap:4px}
  .bar{width:18px;height:8px;border-radius:3px;background:rgba(255,255,255,0.08)}
  .bar.active{background:linear-gradient(90deg,#47d36b,#0f0)}
  .upgradeBtn{background:var(--accent);border:none;padding:6px 10px;border-radius:6px;color:#000;cursor:pointer}
  .upgradeCost{font-size:13px;color:#ddd}

  /* small help note */
  #helpNote{position:absolute; right:12px; top:12px; font-size:13px; color:#ddd; opacity:0.9}

  /* HUD ammo + reload */
  #ammoDisplay { font-weight:700; margin-left:10px; font-family:monospace; }
  #reloadBar {
    position:absolute; left:12px; top:62px; z-index:25;
    width:160px; height:10px; background:rgba(255,255,255,0.06); border-radius:6px; overflow:hidden; display:none;
  }
  #reloadBarInner { height:100%; width:0%; background:linear-gradient(90deg, rgba(0,255,0,0.75), rgba(0,200,0,0.75)); transition:width 0.05s linear; }

  /* Game over UI-style (small, top-left) */
  #gameOverText {
    position: absolute;
    left: 12px;
    top: 62px;
    z-index: 60;
    display: none;
    padding: 6px 10px;
    background: var(--panel);
    border-radius: 8px;
    color: #fff;
    font-weight: 800;
    font-size: 16px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.6);
  }

  /* Heat & grenade HUD */
  #heatBar { position:absolute; left:12px; top:80px; z-index:25; width:120px; height:8px; background:rgba(255,255,255,0.06); border-radius:6px; overflow:hidden; display:none; }
  #heatBarInner { height:100%; width:0%; background:linear-gradient(90deg,#ff7a00,#ff2a00); transition:width 0.06s linear; }
  #grenadeCount { position:absolute; left:12px; top:100px; z-index:25; background:var(--panel); padding:4px 8px; border-radius:6px; font-weight:700; display:none; }
</style>
</head>
<body>
  <div id="menu">
    <h1>CQB SHOOTER</h1>
    <button id="startBtn">Start Game</button>
  </div>

  <div id="hud" style="display:none">
    <div>Score: <span id="score">0</span></div>
    <div id="currentWeapon" style="font-weight:700">Weapon: Pistol</div>
    <div id="ammoDisplay">12 / 12</div>
    <button id="weaponBtn" title="Open weapon menu (E)">Weapons (E)</button>
    <button id="upgradeBtn" title="Open upgrades (U)">Upgrades (U)</button>
  </div>

  <div id="reloadBar"><div id="reloadBarInner"></div></div>
  <div id="heatBar"><div id="heatBarInner"></div></div>
  <div id="grenadeCount">Grenades: <span id="grenades">2</span></div>

  <div id="helpNote" style="display:none">Move: WASD • Aim: Mouse • Shoot: Click • Open weapons: E • Upgrades: U • Reload: R • Throw Grenade: G</div>

  <div id="gameOverText">GAME OVER</div>

  <canvas id="gameCanvas" style="display:none"></canvas>

  <!-- Weapon selection overlay (in-game) -->
  <div id="weaponOverlay" class="popupOverlay" aria-hidden="true">
    <h2>Choose Your Weapon</h2>
    <div class="weaponList" id="weaponList"></div>
    <button id="closeWeapons">Equip & Close (E)</button>
  </div>

  <!-- Upgrades overlay (matches weapon menu style) -->
  <div id="upgradeOverlay" class="popupOverlay" aria-hidden="true">
    <h2>Upgrade — <span id="upgradeWeaponName">Pistol</span></h2>
    <div id="upgradeList"></div>
    <button id="closeUpgrades">Close (U)</button>
  </div>

<script>
/* =========================
   Setup + Globals (mostly unchanged, additions marked)
   ========================= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resizeAll(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  fogCanvas.width = canvas.width;
  fogCanvas.height = canvas.height;
}
window.addEventListener('resize', resizeAll);

const fogCanvas = document.createElement('canvas');
const fogCtx = fogCanvas.getContext('2d');

/* Player */
const player = { x: 400, y: 300, radius: 20, speed: 4, maxHealth: 100, health: 100, displayedHealth: 100, lastDamageTime: 0 };

/* Player state additions */
const playerState = {
  grenades: 2,
  heat: 0,           // flamethrower heat (0..100)
  heatCooling: 0.6,  // heat reduced per frame when not firing
  heatPerFrame: 1.6, // heat added per frame while firing
  heatMax: 100,
  heatCooldownDelay: 800 // ms after overheating before usable
};
let overheatedUntil = 0;

/* Bullets and new particle arrays */
const bullets = [];
const explosions = [];
const particles = []; // for sparks, flame particles, grenade fragments
const grenades = [];  // thrown grenades (pre-explosion)

const walls = [
  { x: 200, y: 150, w: 300, h: 20 },
  { x: 600, y: 400, w: 20, h: 300 },
  { x: 400, y: 600, w: 300, h: 20 },
  { x: 800, y: 200, w: 20, h: 300 }
];

const keys = {};
let mouseX = 0, mouseY = 0, mouseDown = false;
document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
document.addEventListener('mousedown', () => mouseDown = true);
document.addEventListener('mouseup', () => mouseDown = false);

/* HUD + UI */
const hud = document.getElementById('hud');
const startBtn = document.getElementById('startBtn');
const menu = document.getElementById('menu');
const scoreEl = document.getElementById('score');
const weaponBtn = document.getElementById('weaponBtn');
const upgradeBtn = document.getElementById('upgradeBtn');
const weaponOverlay = document.getElementById('weaponOverlay');
const weaponListEl = document.getElementById('weaponList');
const closeWeaponsBtn = document.getElementById('closeWeapons');
const upgradeOverlay = document.getElementById('upgradeOverlay');
const upgradeListEl = document.getElementById('upgradeList');
const closeUpgradesBtn = document.getElementById('closeUpgrades');
const currentWeaponLabel = document.getElementById('currentWeapon');
const helpNote = document.getElementById('helpNote');
const ammoDisplay = document.getElementById('ammoDisplay');
const reloadBar = document.getElementById('reloadBar');
const reloadBarInner = document.getElementById('reloadBarInner');
const upgradeWeaponName = document.getElementById('upgradeWeaponName');
const gameOverText = document.getElementById('gameOverText');
const heatBar = document.getElementById('heatBar');
const heatBarInner = document.getElementById('heatBarInner');
const grenadesEl = document.getElementById('grenades');
const grenadeCountBox = document.getElementById('grenadeCount');

/* Mouse tracking inside canvas */
function attachMouse() {
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
  });
  canvas.addEventListener('click', onPrimaryFire);
}

/* =========================
   WebAudio procedural SFX (no external files required)
   - Flame loop (sustained noise + filter)
   - Shot/impact blips
   - Explosion (swept noise + low sine)
   ========================= */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function createNoiseBuffer(duration = 0.5) {
  const sampleRate = audioCtx.sampleRate;
  const buffer = audioCtx.createBuffer(1, sampleRate * duration, sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 1.2);
  return buffer;
}
const shortNoise = createNoiseBuffer(0.25);
const explosionNoise = createNoiseBuffer(1.2);

function playExplosionSound(volume = 0.7) {
  const now = audioCtx.currentTime;
  const noiseSrc = audioCtx.createBufferSource(); noiseSrc.buffer = explosionNoise;
  const noiseFilt = audioCtx.createBiquadFilter(); noiseFilt.type = 'lowpass'; noiseFilt.frequency.setValueAtTime(1400, now);
  noiseSrc.connect(noiseFilt);
  const bass = audioCtx.createOscillator(); bass.type = 'sine'; bass.frequency.setValueAtTime(120, now);
  const bassGain = audioCtx.createGain(); bassGain.gain.setValueAtTime(0.8 * volume, now);
  bass.connect(bassGain);
  const outGain = audioCtx.createGain(); outGain.gain.setValueAtTime(volume, now);
  noiseFilt.connect(outGain); bassGain.connect(outGain); outGain.connect(audioCtx.destination);
  noiseSrc.start(now); bass.start(now);
  noiseFilt.frequency.exponentialRampToValueAtTime(80, now + 0.9);
  bass.frequency.exponentialRampToValueAtTime(40, now + 0.6);
  noiseSrc.stop(now + 1.1); bass.stop(now + 0.9);
}

function playFlameStart() {
  // one-shot whoosh for ignition
  const now = audioCtx.currentTime;
  const burst = audioCtx.createBufferSource(); burst.buffer = shortNoise;
  const filt = audioCtx.createBiquadFilter(); filt.type = 'highpass'; filt.frequency.setValueAtTime(600, now);
  const g = audioCtx.createGain(); g.gain.setValueAtTime(0.001, now);
  burst.connect(filt); filt.connect(g); g.connect(audioCtx.destination);
  g.gain.exponentialRampToValueAtTime(0.9, now + 0.02);
  g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
  burst.start(now); burst.stop(now + 0.3);
}
let flameLoopNode = null;
function startFlameLoop() {
  if (flameLoopNode) return;
  const now = audioCtx.currentTime;
  const noiseSrc = audioCtx.createBufferSource(); noiseSrc.buffer = createNoiseBuffer(4); noiseSrc.loop = true;
  const filt = audioCtx.createBiquadFilter(); filt.type = 'bandpass'; filt.frequency.setValueAtTime(900, now);
  const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, now);
  noiseSrc.connect(filt); filt.connect(g); g.connect(audioCtx.destination);
  g.gain.exponentialRampToValueAtTime(0.4, now + 0.02);
  noiseSrc.start(now);
  flameLoopNode = { src: noiseSrc, gain: g, filt };
}
function updateFlameLoop(intensity = 0.7) {
  if (!flameLoopNode) return;
  flameLoopNode.gain.gain.setTargetAtTime(Math.max(0.0001, intensity), audioCtx.currentTime, 0.06);
  flameLoopNode.filt.frequency.setTargetAtTime(600 + intensity * 2000, audioCtx.currentTime, 0.06);
}
function stopFlameLoop() {
  if (!flameLoopNode) return;
  flameLoopNode.gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
  flameLoopNode.src.stop(audioCtx.currentTime + 0.25);
  flameLoopNode = null;
}

function playImpactSound(vol = 0.25) {
  const now = audioCtx.currentTime;
  const s = audioCtx.createBufferSource(); s.buffer = shortNoise;
  const f = audioCtx.createBiquadFilter(); f.type = 'highpass'; f.frequency.setValueAtTime(1200, now);
  const g = audioCtx.createGain(); g.gain.setValueAtTime(vol, now);
  s.connect(f); f.connect(g); g.connect(audioCtx.destination);
  s.start(now); s.stop(now + 0.18);
}

/* If you'd like to use external real sounds, these OpenGameArt / Pixabay pages are good places to start:
   - OpenGameArt: fire loop and explosion packs (examples). :contentReference[oaicite:1]{index=1}
   - Pixabay sound search for flamethrower/explosion. :contentReference[oaicite:2]{index=2}
   Replace procedural functions by creating new Audio(src) and .play() where used.
*/

/* =========================
   Weapons (add flamethrower) - magazine/heat integrated
   ========================= */
const weapons = {
  pistol: {
    id: 'pistol', name: 'Pistol', base: { damage: 1, bulletSpeed: 12, fireRate: 250, spread: 0 },
    bulletsPerShot: 1, auto: false, magazineBase: 12, reloadTimeBase: 900
  },
  shotgun: {
    id: 'shotgun', name: 'Shotgun', base: { damage: 1, bulletSpeed: 11, fireRate: 800, spread: 0.6 },
    bulletsPerShot: 6, auto: false, magazineBase: 6, reloadTimeBase: 1200
  },
  smg: {
    id: 'smg', name: 'SMG', base: { damage: 1, bulletSpeed: 14, fireRate: 80, spread: 0.06 },
    bulletsPerShot: 1, auto: true, magazineBase: 30, reloadTimeBase: 1600
  },
  ar: {
    id: 'ar', name: 'Assault Rifle', base: { damage: 2, bulletSpeed: 16, fireRate: 120, spread: 0.04 },
    bulletsPerShot: 1, auto: true, magazineBase: 30, reloadTimeBase: 1400
  },
  sniper: {
    id: 'sniper', name: 'Sniper', base: { damage: 8, bulletSpeed: 38, fireRate: 1200, spread: 0.002 },
    bulletsPerShot: 1, auto: false, special: 'piercing', magazineBase: 5, reloadTimeBase: 2000
  },
  lmg: {
    id: 'lmg', name: 'LMG', base: { damage: 1.2, bulletSpeed: 13, fireRate: 60, spread: 0.09 },
    bulletsPerShot: 1, auto: true, magazineBase: 80, reloadTimeBase: 3000
  },
  rocket: {
    id: 'rocket', name: 'Rocket Launcher', base: { damage: 6, bulletSpeed: 8, fireRate: 1200, spread: 0.01 },
    bulletsPerShot: 1, auto: false, explosive: true, explosionRadius: 80, magazineBase: 1, reloadTimeBase: 1800
  },
  marksman: {
    id: 'marksman', name: 'Marksman Rifle', base: { damage: 6, bulletSpeed: 30, fireRate: 800, spread: 0.008 },
    bulletsPerShot: 1, auto: false, special: 'piercing', magazineBase: 10, reloadTimeBase: 1800
  },
  minigun: {
    id: 'minigun', name: 'Minigun', base: { damage: 0.6, bulletSpeed: 16, fireRate: 30, spread: 0.12 },
    bulletsPerShot: 1, auto: true, magazineBase: 500, reloadTimeBase: 4000
  },

  // Flamethrower:
  flamethrower: {
    id: 'flamethrower', name: 'Flamethrower',
    // It's a continuous weapon: we'll treat fireRate as frame tick spacing, but use heat instead of bullet mag
    base: { damage: 0.45, bulletSpeed: 6, fireRate: 40, spread: 0.18 },
    bulletsPerShot: 1, auto: true, magazineBase: 0, reloadTimeBase: 0,
    usesHeat: true, range: 140
  }
};

/* Upgrades and derived stat initialization (keeps your original upgrade system) */
for (const k in weapons) {
  const w = weapons[k];
  w.upgrades = w.upgrades || { damage: 1, fireRate: 1, reload: 1, ammo: 1 };
  w.maxUpgrade = w.maxUpgrade || 5;
  w.magazineBase = (typeof w.magazineBase !== 'undefined') ? w.magazineBase : (w.magazineBase = (w.magazineBase || 1));
  w.currentAmmo = (w.magazineBase > 0) ? w.magazineBase : 0;
  w.damage = w.base.damage;
  w.fireRate = w.base.fireRate;
  w.reloadTime = w.reloadTimeBase || 1000;
  w.magazine = w.magazineBase || 1;
  w.applyUpgrades = w.applyUpgrades || function() {
    const dmgLevel = w.upgrades.damage;
    w.damage = w.base.damage * (1 + 0.2 * (dmgLevel - 1));
    const frLevel = w.upgrades.fireRate;
    w.fireRate = Math.max(20, Math.round(w.base.fireRate * Math.pow(0.9, frLevel - 1)));
    const rlLevel = w.upgrades.reload;
    w.reloadTime = Math.max(100, Math.round((w.reloadTimeBase || w.reloadTime) * Math.pow(0.9, rlLevel - 1)));
    const amLevel = w.upgrades.ammo;
    w.magazine = Math.max(1, Math.round((w.magazineBase || 1) * (1 + 0.2 * (amLevel - 1))));
    if (typeof w.currentAmmo !== 'number' || w.currentAmmo <= 0) w.currentAmmo = w.magazine;
    if (w.currentAmmo > w.magazine) w.currentAmmo = w.magazine;
  };
}
for (const k in weapons) weapons[k].applyUpgrades();

let currentWeapon = weapons.pistol;
let lastShotTime = 0;

/* Ammo & reload state */
let isReloading = false;
let reloadEndTime = 0;
let reloadWeaponId = null;

/* Build weapon UI (includes flamethrower) */
function buildWeaponUI(){
  weaponListEl.innerHTML = '';
  for(const key in weapons){
    const w = weapons[key];
    const card = document.createElement('div');
    card.className = 'weaponCard' + (w.id === currentWeapon.id ? ' active' : '');
    card.dataset.weapon = w.id;
    const extras = [];
    if (w.auto) extras.push('Auto'); else extras.push('Semi-auto');
    if (w.explosive) extras.push('Explosive');
    if (w.special === 'piercing') extras.push('Piercing');
    if (w.usesHeat) extras.push('Heat');
    card.innerHTML = `
      <div class="weaponName">${w.name}</div>
      <div class="weaponStat">Fire rate: ${w.fireRate} ms</div>
      <div class="weaponStat">Bullets/shot: ${w.bulletsPerShot}</div>
      <div class="weaponStat">Speed: ${w.base.bulletSpeed}</div>
      <div class="weaponStat">Spread: ${w.base.spread}</div>
      <div style="margin-top:6px;color:#bdbdbd;font-size:12px">${extras.join(' • ')}</div>
      <div style="margin-top:6px;color:#bdbdbd;font-size:12px">${w.usesHeat ? 'Range: ' + (w.range || 120) + ' • Heat: yes' : 'Mag: ' + w.magazine}</div>
    `;
    card.addEventListener('click', () => {
      selectWeapon(w.id);
    });
    weaponListEl.appendChild(card);
  }
}
function selectWeapon(id){
  if(!weapons[id]) return;
  currentWeapon = weapons[id];
  lastShotTime = 0;
  currentWeaponLabel.textContent = `Weapon: ${currentWeapon.name}`;
  updateAmmoDisplay();
  Array.from(document.querySelectorAll('.weaponCard')).forEach(c => c.classList.toggle('active', c.dataset.weapon === id));
  // show/hide heat HUD
  if (currentWeapon.usesHeat) { heatBar.style.display = 'block'; } else { heatBar.style.display = 'none'; stopFlameLoop(); }
}

/* =========================
   Upgrade system (unchanged)
   ========================= */
let isUpgradeOpen = false;
function openUpgradeOverlay(){
  isUpgradeOpen = true;
  upgradeOverlay.style.display = 'block';
  upgradeOverlay.setAttribute('aria-hidden','false');
  buildUpgradeUI();
}
function closeUpgradeOverlay(){
  isUpgradeOpen = false;
  upgradeOverlay.style.display = 'none';
  upgradeOverlay.setAttribute('aria-hidden','true');
}
upgradeBtn.addEventListener('click', () => { if (isUpgradeOpen) closeUpgradeOverlay(); else openUpgradeOverlay(); });
closeUpgradesBtn.addEventListener('click', () => closeUpgradeOverlay());

function buildUpgradeUI(){
  upgradeListEl.innerHTML = '';
  const w = currentWeapon;
  upgradeWeaponName.textContent = w.name;
  const stats = [
    { key: 'damage', title: 'Damage' },
    { key: 'fireRate', title: 'Fire Rate' },
    { key: 'reload', title: 'Reload Speed' },
    { key: 'ammo', title: 'Ammo Capacity' }
  ];
  for (const s of stats) {
    const lvl = w.upgrades[s.key] || 1;
    const row = document.createElement('div');
    row.className = 'upgradeRow';
    const title = document.createElement('div'); title.className = 'upgradeTitle'; title.textContent = s.title;
    const bars = document.createElement('div'); bars.className = 'upgradeBars';
    for (let i=1;i<=w.maxUpgrade;i++){
      const b = document.createElement('div'); b.className = 'bar' + (i<=lvl ? ' active' : '');
      bars.appendChild(b);
    }
    const cost = 10 * lvl;
    const costEl = document.createElement('div'); costEl.className = 'upgradeCost';
    costEl.textContent = lvl>=w.maxUpgrade ? 'MAX' : `Upgrade: ${cost} pts`;
    if (lvl < w.maxUpgrade) {
      costEl.style.color = 'var(--accent)';
      costEl.style.textShadow = '0 0 8px rgba(0,255,0,0.25)';
    }
    const btn = document.createElement('button'); btn.className = 'upgradeBtn'; btn.textContent = lvl>=w.maxUpgrade ? 'MAX' : 'Upgrade';
    btn.disabled = (lvl>=w.maxUpgrade);
    btn.addEventListener('click', () => {
      attemptUpgrade(w.id, s.key);
    });
    row.appendChild(title);
    row.appendChild(bars);
    row.appendChild(costEl);
    row.appendChild(btn);
    upgradeListEl.appendChild(row);
  }
}

let score = 0;
function attemptUpgrade(weaponId, statKey){
  const w = weapons[weaponId];
  const lvl = w.upgrades[statKey] || 1;
  if (lvl >= w.maxUpgrade) return;
  const cost = 10 * lvl;
  if (score < cost) { flashInsufficient(); return; }
  score -= cost; scoreEl.textContent = score;
  w.upgrades[statKey] = lvl + 1;
  if (w.applyUpgrades) w.applyUpgrades();
  if (w.currentAmmo > w.magazine) w.currentAmmo = w.magazine;
  if (typeof w.currentAmmo !== 'number' || w.currentAmmo <= 0) w.currentAmmo = w.magazine;
  updateAmmoDisplay();
  buildUpgradeUI();
}

function flashInsufficient(){
  upgradeOverlay.style.boxShadow = '0 8px 40px rgba(255,0,0,0.6)';
  setTimeout(()=> upgradeOverlay.style.boxShadow = '0 8px 30px rgba(0,0,0,0.7)', 360);
}

/* =========================
   Reload logic (unchanged)
   ========================= */
function startReload(force=false){
  if (isReloading) return;
  if (!currentWeapon) return;
  if (currentWeapon.currentAmmo >= currentWeapon.magazine && !force) return;
  isReloading = true;
  reloadWeaponId = currentWeapon.id;
  reloadEndTime = performance.now() + currentWeapon.reloadTime;
  reloadBar.style.display = 'block';
}
function completeReload(){
  if (!isReloading) return;
  const w = weapons[reloadWeaponId];
  if (w) {
    w.currentAmmo = w.magazine;
  }
  if (currentWeapon && currentWeapon.id === reloadWeaponId) updateAmmoDisplay();
  isReloading = false;
  reloadWeaponId = null;
  reloadBar.style.display = 'none';
  reloadBarInner.style.width = '0%';
}
document.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'r') {
    startReload(true);
  }
});

/* =========================
   Fire handling (supports flamethrower and bullets)
   ========================= */
function fireWeapon() {
  const now = performance.now();
  if (!currentWeapon) return;
  // flamethrower uses continuous tick-based firing (we still enforce fireRate spacing)
  if (now - lastShotTime < currentWeapon.fireRate) return;
  if (isReloading) return;
  // handle flamethrower special (heat)
  if (currentWeapon.usesHeat) {
    if (Date.now() < overheatedUntil) { return; }
    // increase heat
    playerState.heat += playerState.heatPerFrame;
    if (playerState.heat >= playerState.heatMax) {
      // overheat
      playerState.heat = playerState.heatMax;
      overheatedUntil = Date.now() + playerState.heatCooldownDelay;
      stopFlameLoop();
      return;
    }
    // create flame particles and short range damage traces
    const coneAngle = Math.atan2(mouseY - player.y, mouseX - player.x);
    // spawn many short flame particles along cone
    for (let i=0;i<4;i++){
      const spread = (Math.random() - 0.5)*currentWeapon.base.spread;
      const ang = coneAngle + spread;
      const dist = Math.random() * (currentWeapon.range || 120);
      particles.push({ x: player.x + Math.cos(ang) * 28, y: player.y + Math.sin(ang) * 28, vx: Math.cos(ang)*(2+Math.random()*2), vy: Math.sin(ang)*(2+Math.random()*2), life: 18+Math.random()*8, size: 6+Math.random()*8, type: 'flame' });
      // damage enemies in short range in front
      for (let j = enemies.length-1; j >= 0; j--) {
        const e = enemies[j];
        const dx = e.x - player.x, dy = e.y - player.y;
        const dAng = Math.atan2(dy,dx);
        const da = Math.abs(((dAng - coneAngle + Math.PI) % (Math.PI*2)) - Math.PI);
        const dd = Math.hypot(dx,dy);
        if (da < 0.6 && dd < (currentWeapon.range || 140) + e.r) {
          // apply burn damage per tick
          e.hp -= (currentWeapon.damage * 0.8); // flamethrower tick
          if (e.hp <= 0) { if (e.type === 'big') { player.health = Math.min(player.maxHealth, player.health + 20); } enemies.splice(j,1); score++; scoreEl.textContent = score; setTimeout(spawnEnemy, 700 + Math.random()*1000); }
        }
      }
    }
    // audio
    startFlameLoop();
    updateFlameLoop(Math.min(1, playerState.heat / playerState.heatMax));
    lastShotTime = now;
    updateAmmoDisplay();
    return;
  }

  // normal bullet weapons:
  if ((currentWeapon.magazine > 0) && currentWeapon.currentAmmo <= 0) { startReload(true); return; }
  lastShotTime = now;
  if (currentWeapon.magazine > 0) currentWeapon.currentAmmo = Math.max(0, currentWeapon.currentAmmo - 1);
  updateAmmoDisplay();

  const baseAngle = Math.atan2(mouseY - player.y, mouseX - player.x);
  const count = currentWeapon.bulletsPerShot;
  if (count === 1) {
    const angle = baseAngle + (Math.random() - 0.5) * (currentWeapon.base.spread || 0);
    const speed = currentWeapon.base.bulletSpeed || 12;
    bullets.push({
      x: player.x + Math.cos(angle) * 28,
      y: player.y + Math.sin(angle) * 28,
      dx: Math.cos(angle) * speed,
      dy: Math.sin(angle) * speed,
      radius: 5, damage: currentWeapon.damage || currentWeapon.base.damage,
      explosive: currentWeapon.explosive || false,
      explosionRadius: currentWeapon.explosionRadius || 0,
      tracer: true
    });
    // short tracer particle
    particles.push({ x: player.x + Math.cos(angle) * 28, y: player.y + Math.sin(angle) * 28, vx: Math.cos(angle) * speed * 0.6, vy: Math.sin(angle) * speed * 0.6, life: 6, size: 2, type: 'tracer' });
  } else {
    for (let i=0;i<count;i++){
      const t = (count===1) ? 0.5 : i/(count-1);
      const off = (t - 0.5) * (currentWeapon.base.spread || 0) + (Math.random()-0.5)*0.02;
      const angle = baseAngle + off;
      const speed = currentWeapon.base.bulletSpeed || 12;
      bullets.push({
        x: player.x + Math.cos(angle) * 28,
        y: player.y + Math.sin(angle) * 28,
        dx: Math.cos(angle) * speed,
        dy: Math.sin(angle) * speed,
        radius: 5, damage: currentWeapon.damage || currentWeapon.base.damage
      });
    }
  }
  // firing audio (small impact-like)
  playImpactSound(0.18);
  if (currentWeapon.currentAmmo <= 0) {
    setTimeout(() => { startReload(true); }, 150);
  }
}

function onPrimaryFire(e){ if (isWeaponOpen || isUpgradeOpen || gameOver) return; fireWeapon(); }
function handleAutoFire() { if (mouseDown && currentWeapon.auto && !isWeaponOpen && !isUpgradeOpen && !gameOver) { fireWeapon(); } }

/* =========================
   Grenade: press G to throw
   - arc + timer -> explosion
   ========================= */
document.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'g') { throwGrenade(); }
});

function throwGrenade(){
  if (playerState.grenades <= 0) return;
  // spawn grenade
  const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
  const speed = 8 + Math.random()*2;
  grenades.push({
    x: player.x + Math.cos(angle) * 24,
    y: player.y + Math.sin(angle) * 24,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed - 2,
    life: 1000 + 400*Math.random(), // ms to explode
    spawn: performance.now(),
    radius: 6
  });
  playerState.grenades -= 1;
  grenadesEl.textContent = playerState.grenades;
  // whoosh sound
  playImpactSound(0.28);
}

/* =========================
   Explosions & particle helpers (visual)
   ========================= */
function createExplosion(x,y,radius,damage){
  explosions.push({ x, y, radius, damage: damage*2, life: 18, maxLife: 18 });
  // big particle burst
  for (let i=0;i<28;i++){
    const a = Math.random()*Math.PI*2;
    const s = 2 + Math.random()*4;
    particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: 24+Math.random()*18, size: 4+Math.random()*6, type: 'spark' });
  }
  playExplosionSound(0.9);
}

/* =========================
   Collision & helpers (unchanged)
   ========================= */
function circleRectCollision(x, y, r, rect) {
  const nearestX = Math.max(rect.x, Math.min(x, rect.x + rect.w));
  const nearestY = Math.max(rect.y, Math.min(y, rect.y + rect.h));
  const dx = x - nearestX; const dy = y - nearestY; return (dx*dx+dy*dy) < (r*r);
}
function checkCollision(x, y, radius) { for (const w of walls) if (circleRectCollision(x,y,radius,w)) return true; return false; }
function drawWalls() { ctx.fillStyle = '#555'; for (const wall of walls) ctx.fillRect(wall.x, wall.y, wall.w, wall.h); }
function lineIntersect(p0, p1, p2, p3) { const s1x = p1.x - p0.x, s1y = p1.y - p0.y; const s2x = p3.x - p2.x, s2y = p3.y - p2.y; const denom = (-s2x * s1y + s1x * s2y); if (denom === 0) return null; const s = (-s1y * (p0.x - p2.x) + s1x * (p0.y - p2.y)) / denom; const t = ( s2x * (p0.y - p2.y) - s2y * (p0.x - p2.x)) / denom; if (s >= 0 && s <= 1 && t >= 0 && t <= 1) return { x: p0.x + (t * s1x), y: p0.y + (t * s1y) }; return null; }

/* =========================
   Game objects (enemies) - same as before
   ========================= */
const enemies = [];
function spawnEnemy() {
  let tries = 0;
  while (tries++ < 80) {
    const x = Math.random() * (canvas.width-100) + 50;
    const y = Math.random() * (canvas.height-100) + 50;
    if (Math.hypot(x-player.x,y-player.y) < 140) continue;
    if (checkCollision(x,y,16)) continue;
    const r = Math.random();
    let type = 'normal';
    if (r < 0.5) type = 'normal';
    else if (r < 0.75) type = 'fast';
    else if (r < 0.9) type = 'heavy';
    else type = 'big';
    let obj;
    if (type === 'fast') {
      obj = { x, y, r: 12, hp: 1, speed: 2.8, color: 'orange', type: 'fast' };
    } else if (type === 'heavy') {
      obj = { x, y, r: 24, hp: 6, speed: 0.9, color: '#8b0000', type: 'heavy' };
    } else if (type === 'big') {
      obj = { x, y, r: 34, hp: 10, speed: 0.7, color: 'rebeccapurple', type: 'big' };
    } else {
      obj = { x, y, r: 16, hp: 2, speed: 1.6, color: 'crimson', type: 'normal' };
    }
    enemies.push(obj);
    return;
  }
}
for (let i=0;i<5;i++) spawnEnemy();

/* =========================
   Weapon & Upgrade toggles (unchanged)
   ========================= */
let isWeaponOpen = false;
function openWeaponOverlay(){ isWeaponOpen = true; weaponOverlay.style.display = 'block'; weaponOverlay.setAttribute('aria-hidden','false'); }
function closeWeaponOverlay(){ isWeaponOpen = false; weaponOverlay.style.display = 'none'; weaponOverlay.setAttribute('aria-hidden','true'); }
weaponBtn.addEventListener('click', () => { if (isWeaponOpen) closeWeaponOverlay(); else { buildWeaponUI(); openWeaponOverlay(); } });
closeWeaponsBtn.addEventListener('click', () => closeWeaponOverlay());
document.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'e') {
    if (isWeaponOpen) closeWeaponOverlay(); else { buildWeaponUI(); openWeaponOverlay(); }
  }
  if (e.key.toLowerCase() === 'u') {
    if (isUpgradeOpen) closeUpgradeOverlay(); else openUpgradeOverlay();
  }
  if (e.key === 'Escape') { if (isWeaponOpen) closeWeaponOverlay(); if (isUpgradeOpen) closeUpgradeOverlay(); }
});

/* =========================
   Game loop (integrates flame, grenade, particles)
   ========================= */
let gameOver = false;
const damagePerHit = 10;
const damageCooldown = 600;

function updateAmmoDisplay(){ if (!currentWeapon) return; ammoDisplay.textContent = `${currentWeapon.currentAmmo || 0} / ${currentWeapon.magazine || 0}`; }

function drawReloadAnimation(progress) {
  const magW = 14, magH = 24; const slide = 24; const eased = (Math.sin((progress - 0.5) * Math.PI) + 1) / 2; const offsetY = -10 + eased * slide; const magX = player.x + 16; const magY = player.y + offsetY; ctx.save(); ctx.translate(magX, magY); const wobble = Math.sin(progress * Math.PI * 4) * 0.08; ctx.rotate(wobble); ctx.fillStyle = '#222'; ctx.fillRect(-magW/2, -magH/2, magW, magH); ctx.strokeStyle = '#666'; ctx.lineWidth = 2; ctx.strokeRect(-magW/2, -magH/2, magW, magH); ctx.restore(); }

function gameLoop() {
  const paused = isWeaponOpen || isUpgradeOpen || gameOver;
  const now = performance.now();

  // reload UI
  if (isReloading) {
    const remaining = Math.max(0, reloadEndTime - now);
    const total = (weapons[reloadWeaponId] && weapons[reloadWeaponId].reloadTime) ? weapons[reloadWeaponId].reloadTime : 1000;
    const prog = 1 - remaining / total; reloadBarInner.style.width = `${Math.min(100, Math.floor(prog * 100))}%`;
    if (now >= reloadEndTime) completeReload();
  }

  if(!paused){
    // movement
    let nx = player.x, ny = player.y;
    if (keys['w']) ny -= player.speed;
    if (keys['s']) ny += player.speed;
    if (keys['a']) nx -= player.speed;
    if (keys['d']) nx += player.speed;
    if (!checkCollision(nx, player.y, player.radius)) player.x = nx;
    if (!checkCollision(player.x, ny, player.radius)) player.y = ny;
    handleAutoFire();

    // bullets update & collisions
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i]; b.x += b.dx; b.y += b.dy;
      if (b.x < -50 || b.x > canvas.width + 50 || b.y < -50 || b.y > canvas.height + 50) { if (b.explosive) createExplosion(b.x, b.y, b.explosionRadius || 60, b.damage); bullets.splice(i,1); continue; }
      if (walls.some(w => circleRectCollision(b.x, b.y, b.radius, w))) { if (b.explosive) createExplosion(b.x, b.y, b.explosionRadius || 60, b.damage); bullets.splice(i,1); continue; }
      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j]; if (Math.hypot(e.x - b.x, e.y - b.y) < e.r + b.radius) {
          e.hp -= b.damage; if (!b.piercing) bullets.splice(i,1);
          // spawn sparks on hit
          particles.push({ x: b.x, y: b.y, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, life: 10, size: 2 + Math.random()*3, type:'spark' });
          if (e.hp <= 0) {
            if (e.type === 'big') { player.health = Math.min(player.maxHealth, player.health + 20); }
            enemies.splice(j,1); score++; scoreEl.textContent = score; setTimeout(spawnEnemy, 700 + Math.random()*1000);
          }
          if (b.explosive) createExplosion(b.x, b.y, b.explosionRadius || 60, b.damage);
          break;
        }
      }
    }

    // grenades flight + explode
    for (let i = grenades.length - 1; i >= 0; i--) {
      const g = grenades[i];
      const age = performance.now() - g.spawn;
      g.vy += 0.16; // gravity
      g.x += g.vx; g.y += g.vy;
      g.vx *= 0.995; g.vy *= 0.995;
      if (walls.some(w => circleRectCollision(g.x, g.y, g.radius, w))) { // bounce a little
        g.vx *= -0.4; g.vy *= -0.4;
        particles.push({ x: g.x, y: g.y, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, life: 8, size: 2, type:'spark' });
      }
      if (age >= g.life) {
        // explode
        createExplosion(g.x, g.y, 96, 6);
        // AoE damage to enemies
        for (let j = enemies.length-1; j >= 0; j--) {
          const e = enemies[j]; const d = Math.hypot(e.x - g.x, e.y - g.y);
          if (d < 96 + e.r) { e.hp -= 6; if (e.hp <= 0) { if (e.type === 'big') { player.health = Math.min(player.maxHealth, player.health + 20); } enemies.splice(j,1); score++; scoreEl.textContent = score; setTimeout(spawnEnemy, 700 + Math.random()*1000); } }
        }
        grenades.splice(i,1);
      }
    }

    // explosion effects lifecycle
    for (let k = explosions.length - 1; k >= 0; k--) {
      const ex = explosions[k]; ex.life -= 1; if (ex.life === ex.maxLife - 1) { for (let j = enemies.length - 1; j >= 0; j--) { const e = enemies[j]; const d = Math.hypot(e.x - ex.x, e.y - ex.y); if (d < ex.radius + e.r) { e.hp -= ex.damage; if (e.hp <= 0) { if (e.type === 'big') { player.health = Math.min(player.maxHealth, player.health + 20); } enemies.splice(j,1); score++; scoreEl.textContent = score; setTimeout(spawnEnemy, 700 + Math.random()*1000); } } } } if (ex.life <= 0) explosions.splice(k,1); }

    // enemy movement & contact damage
    for (const e of enemies) {
      const ang = Math.atan2(player.y - e.y, player.x - e.x);
      let ex = e.x + Math.cos(ang) * e.speed;
      let ey = e.y + Math.sin(ang) * e.speed;
      if (!checkCollision(ex, e.y, e.r)) e.x = ex;
      if (!checkCollision(e.x, ey, e.r)) e.y = ey;
      const dist = Math.hypot(e.x - player.x, e.y - player.y);
      if (dist < e.r + player.radius) {
        if (now - player.lastDamageTime > damageCooldown) {
          player.lastDamageTime = now; player.health -= damagePerHit;
          if (player.health < 0) player.health = 0;
          if (player.health <= 0) { gameOver = true; gameOverText.style.display = 'block'; }
        }
      }
    }

    // particles update
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx; p.y += p.vy; p.vx *= 0.98; p.vy *= 0.98; p.life -= 1;
      if (p.type === 'flame') { p.size *= 0.98; p.vy -= 0.03; }
      if (p.life <= 0) particles.splice(i,1);
    }

    // heat cooling when not firing flamethrower
    if (!mouseDown || !currentWeapon.usesHeat) {
      if (playerState.heat > 0) playerState.heat = Math.max(0, playerState.heat - playerState.heatCooling);
      updateFlameLoop(Math.max(0, playerState.heat / playerState.heatMax));
      if (!currentWeapon.usesHeat) stopFlameLoop();
      if (Date.now() < overheatedUntil) {
        // show some red pulse perhaps (left as UI exercise)
      }
    }
  }

  // rendering
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#222'; ctx.fillRect(0,0,canvas.width,canvas.height);
  drawWalls();

  // draw enemies
  for(const e of enemies){
    ctx.fillStyle = e.color || 'crimson';
    ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#111';
    const eyeOffsetX = Math.min(6, e.r * 0.25);
    const eyeOffsetY = Math.min(4, e.r * 0.15);
    const eyeSize = Math.max(1.5, e.r * 0.12);
    ctx.beginPath(); ctx.arc(e.x - eyeOffsetX, e.y - eyeOffsetY, eyeSize, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(e.x + eyeOffsetX, e.y - eyeOffsetY, eyeSize, 0, Math.PI*2); ctx.fill();
  }

  // bullets & explosion visuals
  for(const b of bullets){
    ctx.fillStyle = b.explosive ? '#ff8c00' : 'yellow';
    ctx.beginPath(); ctx.arc(b.x,b.y,b.radius,0,Math.PI*2); ctx.fill();
    if (b.tracer) { ctx.globalAlpha = 0.7; ctx.fillRect(b.x-2, b.y-1, 4, 2); ctx.globalAlpha = 1; }
  }
  for(const ex of explosions){
    const t = 1 - (ex.life / ex.maxLife); const r = ex.radius * t;
    ctx.beginPath(); ctx.fillStyle = `rgba(255,160,0,${0.35*(1-t)})`; ctx.arc(ex.x, ex.y, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.strokeStyle = `rgba(255,220,120,${0.6*(1-t)})`; ctx.lineWidth = 2; ctx.arc(ex.x, ex.y, r, 0, Math.PI*2); ctx.stroke();
  }

  // particles (flame, sparks)
  for (const p of particles) {
    if (p.type === 'flame') {
      const a = Math.max(0, p.life / 30);
      ctx.beginPath();
      const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size*2);
      grad.addColorStop(0, `rgba(255,230,160,${0.9*a})`);
      grad.addColorStop(0.5, `rgba(255,120,40,${0.6*a})`);
      grad.addColorStop(1, `rgba(120,20,0,${0.05*a})`);
      ctx.fillStyle = grad;
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
    } else if (p.type === 'spark') {
      ctx.fillStyle = `rgba(255,220,120,${Math.max(0.15, p.life/20)})`;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    } else if (p.type === 'tracer') {
      ctx.fillStyle = 'rgba(255,255,200,0.9)';
      ctx.fillRect(p.x, p.y, 3, 2);
    }
  }

  // draw grenades
  for (const g of grenades) {
    ctx.beginPath(); ctx.fillStyle = '#444'; ctx.arc(g.x, g.y, g.radius, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle = '#ffb347'; ctx.arc(g.x, g.y, Math.max(1, g.radius-2), 0, Math.PI*2); ctx.fill();
  }

  // player and reload/tilt
  const playerAng = Math.atan2(mouseY - player.y, mouseX - player.x);
  ctx.save(); ctx.translate(player.x, player.y);
  if (isReloading && reloadWeaponId === currentWeapon.id) { const now2 = performance.now(); const remaining = Math.max(0, reloadEndTime - now2); const total = currentWeapon.reloadTime; const prog = 1 - remaining / total; const tilt = Math.sin(prog * Math.PI * 3) * 0.15; ctx.rotate(playerAng + tilt); } else { ctx.rotate(playerAng); }
  ctx.fillStyle = '#2ecc71'; ctx.fillRect(-10,-15,20,30); ctx.fillStyle = '#888'; ctx.fillRect(10,-4,26,8); ctx.restore();

  // fog of war
  fogCtx.fillStyle = 'rgba(0, 0, 0, 0.04)'; fogCtx.fillRect(0,0,fogCanvas.width,fogCanvas.height);
  const maxLength = 1000; const coneSpread = Math.PI / 6; const coneAngle = Math.atan2(mouseY - player.y, mouseX - player.x); const rayCount = 60; const conePoints = [];
  for (let i = -coneSpread / 2; i <= coneSpread / 2; i += coneSpread / rayCount) {
    const rayAngle = coneAngle + i; let endX = player.x + Math.cos(rayAngle) * maxLength; let endY = player.y + Math.sin(rayAngle) * maxLength;
    for (const w of walls) {
      const edges = [ [{ x: w.x, y: w.y }, { x: w.x + w.w, y: w.y }], [{ x: w.x + w.w, y: w.y }, { x: w.x + w.w, y: w.y + w.h }], [{ x: w.x + w.w, y: w.y + w.h }, { x: w.x, y: w.y + w.h }], [{ x: w.x, y: w.y + w.h }, { x: w.x, y: w.y }] ];
      for (const [a, b] of edges) { const hit = lineIntersect({ x: player.x, y: player.y }, { x: endX, y: endY }, a, b); if (hit) { const dist = Math.hypot(hit.x - player.x, hit.y - player.y); const curDist = Math.hypot(endX - player.x, endY - player.y); if (dist < curDist) { endX = hit.x; endY = hit.y; } } }
    }
    conePoints.push({ x: endX, y: endY });
  }
  fogCtx.globalCompositeOperation = 'destination-out'; fogCtx.beginPath(); fogCtx.moveTo(player.x, player.y); for (const p of conePoints) fogCtx.lineTo(p.x, p.y); fogCtx.closePath(); fogCtx.fillStyle = 'rgba(255,255,255,0.9)'; fogCtx.fill(); fogCtx.globalCompositeOperation = 'source-over';
  const gradient = fogCtx.createRadialGradient(player.x, player.y, 0, player.x, player.y, maxLength); gradient.addColorStop(0, 'rgba(0,0,0,0)'); gradient.addColorStop(0.4, 'rgba(0,0,0,0.08)'); gradient.addColorStop(1, 'rgba(0,0,0,0.9)'); fogCtx.fillStyle = gradient; fogCtx.fillRect(0,0,fogCanvas.width,fogCanvas.height);
  ctx.drawImage(fogCanvas,0,0);

  // health bar above player
  player.displayedHealth += (player.health - player.displayedHealth) * 0.12;
  const hbWidth = 72, hbHeight = 10; const hbX = player.x - hbWidth/2, hbY = player.y - player.radius - 18;
  ctx.save(); ctx.globalAlpha = 0.95; ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(hbX-2, hbY-2, hbWidth+4, hbHeight+4); ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1; ctx.strokeRect(hbX-2, hbY-2, hbWidth+4, hbHeight+4);
  const healthRatio = Math.max(0, Math.min(1, player.displayedHealth / player.maxHealth));
  function healthColor(ratio){ if (ratio > 0.5) { const t = (ratio - 0.5) * 2; const r = Math.round(255 * (1 - t)); const g = 255; return `rgb(${r},${g},0)`; } else { const t = ratio * 2; const r = 255; const g = Math.round(255 * t); return `rgb(${r},${g},0)`; } }
  ctx.fillStyle = healthColor(healthRatio); ctx.fillRect(hbX, hbY, hbWidth * healthRatio, hbHeight);
  ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(hbX + hbWidth * healthRatio, hbY, hbWidth * (1 - healthRatio), hbHeight);
  ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.font = '10px system-ui,Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(`${Math.round(player.health)}/${player.maxHealth}`, player.x, hbY + hbHeight/2);
  ctx.restore();

  if (isReloading && reloadWeaponId === currentWeapon.id) { const now3 = performance.now(); const remaining2 = Math.max(0, reloadEndTime - now3); const total2 = currentWeapon.reloadTime; const prog2 = Math.min(1, Math.max(0, 1 - remaining2 / total2)); drawReloadAnimation(prog2); }
  if (isWeaponOpen || isUpgradeOpen) { ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillRect(0,0,canvas.width,canvas.height); }

  if (gameOver) { gameOverText.style.display = 'block'; }

  // update HUD elements
  heatBarInner.style.width = `${Math.round(100 * (playerState.heat / playerState.heatMax))}%`;
  grenadesEl.textContent = playerState.grenades;
  grenadeCountBox.style.display = 'block';

  requestAnimationFrame(gameLoop);
}

/* =========================
   Start game + wiring
   ========================= */
startBtn.addEventListener('click', () => {
  // resume audio context on user gesture
  if (audioCtx.state === 'suspended') audioCtx.resume();
  menu.style.display = 'none'; canvas.style.display = 'block'; hud.style.display = 'flex'; helpNote.style.display = 'block'; resizeAll(); attachMouse(); buildWeaponUI(); selectWeapon('pistol'); requestAnimationFrame(gameLoop);
});

weaponListEl.addEventListener('click', (e) => { const card = e.target.closest('.weaponCard'); if (card) selectWeapon(card.dataset.weapon); });
closeWeaponsBtn.addEventListener('click', () => closeWeaponOverlay());

function createExplosion(x,y,radius,damage){
  explosions.push({ x, y, radius, damage: damage*2, life: 18, maxLife: 18 });
}

/* init */
buildWeaponUI(); selectWeapon('pistol'); updateAmmoDisplay();
</script>
</body>
</html>
